package template

import (
	"bytes"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"github.com/sirupsen/logrus"
)

const (
	packageTT = `// Code generated by thrift2interface. DO NOT EDIT.

package [[.PackageName]]
`

	importTT = `
import (
	"context"
[[range $k, $v := .NamespaceAlias]][[if eq $k $v]]
	"[[$.Prefix]]thrift_gen/[[replaceAll $k "." "/"]]"
[[else]]
	[[$v]] "[[$.Prefix]]thrift_gen/[[replaceAll $k "." "/"]]"[[end]][[end]]
)
`

	interfaceTT = `
type [[.ServiceName]]Interface interface {[[range $m := .Methods]][[if and (not $m.Request) (not $m.Response)]]
	[[$m.Name]](ctx context.Context) (err error)[[else if and $m.Request (not $m.Response)]]
	[[$m.Name]](ctx context.Context, request *[[index $.NamespaceAlias (index $.PrefixedStructToFullNamespace $m.Request)]].[[index $.PrefixedStructToName $m.Request]]) (err error)[[else if and (not $m.Request) $m.Response]]
	[[$m.Name]](ctx context.Context) (response *[[index $.NamespaceAlias (index $.PrefixedStructToFullNamespace $m.Response)]].[[index $.PrefixedStructToName $m.Response]], err error)[[else if and $m.Request $m.Response]]
	[[$m.Name]](ctx context.Context, request *[[index $.NamespaceAlias (index $.PrefixedStructToFullNamespace $m.Request)]].[[index $.PrefixedStructToName $m.Request]]) (response *[[index $.NamespaceAlias (index $.PrefixedStructToFullNamespace $m.Response)]].[[index $.PrefixedStructToName $m.Response]], err error)[[end]][[end]]
}
`
)

var Logger = logrus.New()

type Method struct {
	Name     string
	Request  string
	Response string
}

func NewMethod() (*Method, error) {
	m := new(Method)
	return m, nil
}

type MetaInterface struct {
	// github.com/{:group}/{:project}
	Prefix string
	// package name for generated files
	PackageName string
	// thrift service name
	ServiceName string
	// methods of current interface
	Methods []*Method

	// parsed thrift files
	ThriftFiles map[string]string
	// prefixed.struct to Name
	PrefixedStructToName map[string]string
	// prefixed.struct to full namespace
	PrefixedStructToFullNamespace map[string]string
	// namespace aliases for current interface, FullNamespace(abc.def.ghi) => lowerCamelNamespace(abcDefGhi)
	NamespaceAlias map[string]string
}

func NewMetaInterface() *MetaInterface {
	return &MetaInterface{
		Methods:                       make([]*Method, 0),
		ThriftFiles:                   make(map[string]string),
		PrefixedStructToName:          make(map[string]string),
		PrefixedStructToFullNamespace: make(map[string]string),
		NamespaceAlias:                make(map[string]string),
	}
}

func (mi *MetaInterface) String() string {
	Logger.Level = logrus.InfoLevel
	Logger.Formatter = &logrus.TextFormatter{
		FullTimestamp: true,
	}

	// TODO `a.b_c` and `a_b.c` would get the same alias name in this way
	// TODO this could be fixed by over-writing namespace alias by providing a specific arg like `-nsAlias`

	// get `lowerCamelNamespace` from `full_name.space`, e.g.
	// 1. accurate.branch => accurateBranch
	// 2. pay_forward => payForward
	for _, m := range mi.Methods {
		if ns, ok := mi.PrefixedStructToFullNamespace[m.Request]; ok {
			mi.NamespaceAlias[ns] = strcase.ToLowerCamel(strings.ReplaceAll(ns, ".", " "))
		}

		if ns, ok := mi.PrefixedStructToFullNamespace[m.Response]; ok {
			mi.NamespaceAlias[ns] = strcase.ToLowerCamel(strings.ReplaceAll(ns, ".", " "))
		}
	}

	var buffer strings.Builder

	// parse `package...`
	packageBuffer := &bytes.Buffer{}
	packageTpl := template.New("package").Delims("[[", "]]")
	_, _ = packageTpl.Parse(packageTT)
	_ = packageTpl.Execute(packageBuffer, mi)
	buffer.Write(packageBuffer.Bytes())

	// parse `import ...`
	if len(mi.Methods) > 0 {
		importBuffer := &bytes.Buffer{}
		importTpl := template.New("import").Delims("[[", "]]").Funcs(template.FuncMap{
			"replaceAll": strings.ReplaceAll,
		})
		_, _ = importTpl.Parse(importTT)
		_ = importTpl.Execute(importBuffer, mi)
		buffer.Write(importBuffer.Bytes())
	}

	// parse `interface ...`
	interfaceBuffer := &bytes.Buffer{}
	interfaceTpl := template.New("interface").Delims("[[", "]]")
	_, _ = interfaceTpl.Parse(interfaceTT)
	_ = interfaceTpl.Execute(interfaceBuffer, mi)
	buffer.Write(interfaceBuffer.Bytes())

	Logger.Infof("mi.Prefix: %s", mi.Prefix)
	Logger.Infof("mi.PackageName: %s", mi.PackageName)
	Logger.Infof("mi.ServiceName: %s", mi.ServiceName)
	for idx, m := range mi.Methods {
		Logger.Infof("mi.Methods[%d]: %+v", idx, m)
	}
	Logger.Infof("mi.ThriftFiles: %+v", mi.ThriftFiles)
	Logger.Infof("mi.PrefixedStructToName: %+v", mi.PrefixedStructToName)
	Logger.Infof("mi.PrefixedStructToFullNamespace: %+v", mi.PrefixedStructToFullNamespace)
	Logger.Infof("mi.NamespaceAlias: %+v", mi.NamespaceAlias)

	return buffer.String()
}
